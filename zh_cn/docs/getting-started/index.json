[{"content":"Changelog Changes of git-repo.\n0.7.7 (2020-12-15) Improvements:\n  sync: Set default tracking branch even for fixed revision\n  upload: do not upload fixed revision if not changed\n  helper: add new field pushurl in ssh-info\n  project: default use pushurl defined in manifest file instead of ssh_info resp\n  workspace: show error if review is undefined for remote\n  test: result of Variant() may change on different env\n  manifest: Merge duplicate fields if attribute override is true\n  ssh-info api: add new field review_ref\nAdd new member field review_ref in ssh_info API. When downloading\na review, return the reference name by parsing the pattern defined in\nreview_ref of ssh_info.\n  Bugfix and style:\n Bug: do not set push.default for repository upload: create parent dir for cache of upload-options upload: fix warning of redundant type  0.7.6 (2020-10-13) Improvements:\n Add http proxy support in command git-repo upgrade Fix http proxy support for API call of ssh-info  Bugfix:\n go 1.15 compatible issue: not add rune with int  0.7.5 (2020-09-08) Improvements:\n Support using http proxy when access ssh_info API prune: drop branches without a tracking branch start: not setup tracking branch for immutable rev  Bugfix:\n bugfix: close project.list file before rename Transfer repository from aliyun to alibaba  0.7.4 (2020-03-03) Bugfix:\n To prevent wrong flag for OpenFile, use new file package fix: config example file is not completely overwritten Set proper Revision for manifest project sync: remove unused and unsafe code init: detach manifests project for immutable revision init: when switch manifest branch, use hard reset ssh-info: run ssh_info once for the same hosts  0.7.3.1 (2020-01-13)  Windows: fix wrong URL for repos of a manifest project.  0.7.3 (2020-01-11)  The first release on github.com: github.com/aliyun/git-repo upgrade: download and install tar.gz/zip package README: how to use git-repo upload: confirm all upload tasks if no editor defined editor: search editor from candidates editor: work with editor path with spaces in git-bash upgrade: get program path using os.Executable test: fixed test cases for Linux  0.7.1 (2020-01-02) New features:\n Add helper for protocol extension, and use can add external helper. Smart selection of remote if repository has many remotes defined. AGit-Flow 2.0: set AGIT_FLOW environment for git connection. AGit-Flow 2.0: support version of ssh_info response. AGit-Flow 2.0: multiple users working on one code review. AGit-Flow 2.0: force push prevention if oldoid is provided.  Refactors, Enhancements and bugfixes:\n Many refactors, such as project.Remote. upload: can upload repo managed by git-worktree path: IsGitDir work with git worktree command version: add compatible issue for version below 2.9.0 upload: fallback to ~/.git-repo/UPLOAD_OPTIONS if no file found  0.6.1 (2019-11-10)  manifest: repo compatible parsing for project revision  0.6.0 (2019-11-08) NOTE: All users are suggested to upgrade to this version. Local changed files\nwill not be overwritten.\n Show project path in log message as prompt init: force create default branch for manifest project sync: do not overwrite local changed files sync: sync -d: always detach even if nothing changed sync: should not make manifest project detached init: no need to set color if color.ui defined in git global/system config by setting app.git.repo.disabled can git-repo for certain workspace init: use git-init command to create repository  0.5.1 (2019-09-09) New features:\n upload: cache different upload options settings for different target branch upload: only show title and description in editor for upload for the 1st time Some commands work for repo in mirror mode  Refactors, Enhancements and bugfixes:\n Disable upx, because some Mac users report errors refactor: rename variables name, such as RepoRoot refactor: Add DotGit, SharedGitDir in repository  0.5.0 (2019-08-20) New features:\n New cmd: git repo abandon New cmd: git repo prune New command: git repo manifest cmd/manifest: freeze manifest revision if provided -r option  Refactors, Enhancements and bugfixes:\n color: add Hilight and Dim methods refactor: do not check Remote type to get reviewable branch repository: get last modified of a revision bugfix: not change Revision during network-half refactor: make WorkRepository as embedding struct for Project go.mod: update goconfig, check cache against file size refactor: rename Path field name of Repository to RepoDir refactor: remove ObjectRepository from project refactor: IsClean only returns one boolean test: add test cases for cmd/manifest test: update test cases for manifest refactor: rename command executable entrance name test: remove pipes, which suppress errors being report  0.4.2 (2019-08-08)  Compress binaries using UPX  0.4.1 (2019-08-07)  peer-review: support \u0026ndash;remote and \u0026ndash;dest option New command: git repo list download: support \u0026ndash;remote option compatibility: Use push options only if git is greater than 2.10.0 compatibility: Show compatible issues of git versions compatibility: Fix compatible issue of Gerrit hook compatibility: Use absolute path for \u0026lsquo;include.path\u0026rsquo; directive README: add badge for CI build status compatibility: Use strings.Replace to be compatible with go 1.11 compatibility: enable GO111MODULE for build and test compatibility: remove test case which depends on higher version of git doc: add godoc download: cherry-pick all commits for one code review  0.3.1 (2019-6-26) Enhancement and bugfix:\n bugfix: add protection for write git extra config file Only set push.default to nothing if it is unset Makefile: build with vendor and new release target Ignore vendor dir filter: ignore errors for smudge debug: add more debug info for repo sync upload: clean published refs for single mode  0.3.0 (2019-6-22) DEPRECATED New Features:\n Add alias command: git download New command: download, for offline code review Add \u0026ndash;no-cache option to ignore ssh_info API cache config: add new filter driver keyword-subst New command: filter, for keyword-subst content filter Install Gerrit hooks if review server is Gerrit Set push.default to nothing if remote is reviewable  Enhancement and bugfix:\n test: change branch name to upper case for test goconfig: fix upper case section name issue refactor LoadRemote for single repository workspace ParseGitURL can parse file:// and other protocol test: add mock options for git-repo sync command test: add test cases for git-repo filter sync: default use 4 jobs test: add test case for git pr \u0026ndash;br  Not quit immediately if cannot get review URL refactor: delay load remote for GitWorkspace Only save config for DisableDefaultPush when necessary Format every multi-log imports by adding alias log Fix some spellings  0.2.1 (2019-6-26) Enhancement and bugfix:\n bugfix: add protection for write git extra config file Makefile: build with vendor and new release target  0.2.0 (2019-6-9) DEPRECATED  \u0026ldquo;git repo \u0026ndash;version\u0026rdquo; follows the same rule as version command test: add test cases for submodule projects refactor: urlJoin should keep spaces unchanged Add build tag for windows build support test: use git peer-review instead of git review When comparing, undefined version is lower than others New alias: git pr, stands for git peer-review version: check if git-repo aliases can be used safely Install ~/.git-repo/config.yml.example file refactor: store extra git config and comments in string  0.1.0 (2019-6-5)  upgrade: show download progress upgrade: add \u0026ndash;no-cert-checks option upgrade: validate package by sha256 sum and gpg signature refactor: viper only bind necessary flags in rootcmd bugfix: continue push if consume yes on dirty worktree  0.0.3 (2019-5-29) New feature:\n New command: git repo upgrade New command: git repo status New command: git-repo forall  Enhancement and bugfix:\n Get project\u0026rsquo;s HEAD from .gitdir inside worktree go.mod: update modules goconfig and multi-log refactor: move executeResult from forall to project sync: not quit if fail to check remote server type sync: return error if work repo is nil when syncing goconfig: fix index out of range bug upload: use knownReviewHosts to help to find review URL upload: show log info if cannot upload a branch upload: one dialog for options and branches edition upload: use more readable upload options message upload: New option \u0026ndash;no-edit Update edit script error message Open an editor for user to custom upload options refactor: parse reviewers later in UploadAndReport method  0.0.2 (2019-5-20)  test: add test case for install hooks Link Gerrit hooks when sync repo from Gerrit Install git-hook templates to ~/.git-repo/hooks LinkManifest failed if cannot find manifest file refactor: use NewEmptyRepoWorkSpace for initial workspace If init from a wrong URL, remove and quit sync: segfault: check if ws.Manifest is nil upload: add debug info for upload command Encode reviewers and cc using encodeString test: fixed review test URL If SSH port is 29418, set remote type to Gerrit Hide standard SSH port for SSHInfo refactor: handle review URL for single git repository Do not add \u0026ndash;receive-pack option for http URL when pushing Check git URL using config.ParseGitURL Not check ssh_info, if review URL is rsync protocol refactor: move git address pattern to config Read ReviewURL from git config remote.origin.review test: mock ssh-info API when calling git-repo sync sync: call ssh_info API and install hooks if remote is Gerrit test: add test cases for git review (upload \u0026ndash;single) Add alias command \u0026lsquo;git review\u0026rsquo;  0.0.1 (2019-5-14)  Initial version  ","description":"","id":0,"section":"","tags":null,"title":"变更说明","uri":"/zh_cn/changelog/"},{"content":"快速开始 步骤 1：安装 git-repo 访问 git-repo 的下载页面: https://github.com/alibaba/git-repo-go/releases。\n根据您平台的类型，下载合适的软件包。然后将下载并解压缩后的 git-repo 文件拷贝到可执行目录中（如 Linux 下的 /usr/local/bin 目录），即完成安装。\n步骤 2：运行 git-repo 初次运行任意 git-repo 子命令，会完成一些初始化工作。例如执行下面的命令查看版本号：\ngit repo version  步骤 3：单仓库下发起代码评审 如果工作区当前分支未关联远程分支，先执行操作和远程仓库的远程分支建立关联。例如：如下命令建立和 origin 远程仓库的 master 分支建立关联。\ngit branch -u origin/master  发起代码审核，执行如下命令：\ngit pr  步骤 4：多仓库工作流 git-repo 支持 Android 式的多仓库工作流。\n  创建工作区。\n $ mkdir workspace $ cd workspace    下载 manifest 清单仓库，初始化工作区。\n $ git repo init -u \u0026lt;manifest repository\u0026gt;    按照 Manifest 清单仓库中的文件，下载各个子仓库的代码，并检出到工作区。\n $ git repo sync    创建开发分支。\n $ git repo start --all \u0026lt;branch/name\u0026gt;    在工作区中开发，每个仓库的改动，在各自仓库中完成提交。\n  执行下面命令，扫描工作区所有仓库的改动，逐个向上游仓库发起代码评审。\n $ git repo upload    ","description":"","id":1,"section":"docs","tags":null,"title":"快速开始","uri":"/zh_cn/docs/getting-started/quickstart/"},{"content":"依赖 git-repo 依赖 git，在安装 git-repo 之前，需要确保已经安装了 git 2.10.0 以上版本。\n下载和安装 git-repo   访问 git-repo 的下载页面: https://github.com/alibaba/git-repo-go/releases。\n根据您的平台类型（Linux、Mac、或是 Windows），CPU 类型（amd64 或 386）下载并展开压缩包。\n  如果是 Linux 或者 Mac OS X 平台，为下载文件设置可执行权限。例如：\n $ chmod a+x git-repo    将下载的可执行文件复制到可执行目录。对于 Linux 和 Mac OS X 平台，这个目录可以是\n/usr/local/bin 或者其他可执行目录。对于 Windows 平台，这个目录可能是 C:\\Windows\\system32。\n $ cp git-repo /usr/local/bin/    ","description":"","id":2,"section":"docs","tags":null,"title":"安装 git-repo","uri":"/zh_cn/docs/getting-started/installation/"},{"content":"运行 git-repo 初次运行任意 git-repo 子命令，会完成一些初始化工作，例如：对 Git 配置文件进行扩展。\n因此 git-repo 安装完毕后，可以执行如下命令。\n$ git repo --version  说明：上面命令中 git 和 repo 之间可以不再需要短线，因为 Git 自动将具有类似 git-\u0026lt;subcmd\u0026gt; 的可执行文件视为自己的子命令。\n查看 git-repo 的帮助 执行下面命令查看 git-repo 的帮助：\n$ git repo -h  或者\n$ git repo  注意：如果使用 git repo --help 或者 git help repo，则无法显示 git-repo 的帮助。因为这些命令激活了 git 的 man 手册，而非 git-repo 内置的帮助系统。\ngit repo 有很多子命令。可以用如下命令查看子命令的帮助：\n$ git repo help init $ git repo help sync  ","description":"","id":3,"section":"docs","tags":null,"title":"运行 git-repo","uri":"/zh_cn/docs/getting-started/running/"},{"content":"升级 git-repo 运行下面命令升级 git-repo：\n$ git repo upgrade  自动下载相应平台的 git-repo 升级包，完成应用的替换和升级。\n如果由于文件权限或者其它原因导致升级失败，会给出错误提示。例如：\n$ git repo upgrade Download git-repo: ############################################################ 100% +--------------------------------------------------------------------------------+ | Fail to upgrade. Please copy | | /var/folders/5d/21v9l2z12j/T/git-repo-0.2.0-619707833 | | to | | /usr/bin/git-repo | | by hands | +--------------------------------------------------------------------------------+ Error: upgrade failed  遇到类似上面的错误提示，手工完成文件复制。例如：\n$ sudo cp /var/folders/5d/21v9l2z12j/T/git-repo-0.2.0-619707833 /usr/bin/git-repo  ","description":"","id":4,"section":"docs","tags":null,"title":"升级 git-repo","uri":"/zh_cn/docs/getting-started/upgrade/"},{"content":"大多数用户参与的项目是一个代码仓。对于单仓库操作， git-repo 提供了如下命令扩展：\n git peer-review，或 git pr: 创建代码评审。 git download: 下载评审的代码到本地。 git abandon: 清理当前完成评审发起的分支。  使用 git-repo 针对单仓库系统的示意如下：\n  图: git-repo 针对单仓库的操作\n  ","description":"","id":5,"section":"docs","tags":null,"title":"单仓库协同概览","uri":"/zh_cn/docs/single-repo/overview/"},{"content":"git-repo 针对常用的单仓库的工作区，提供了快捷的创建代码评审的命令：git peer-review。该命令可以简写为 git pr 或者 git review。\n1. 创建代码评审 使用 git peer-review 命令创建代码评审的步骤如下：\n1.1 克隆远程仓库到工作区 克隆远程仓库到本地工作区。（如果工作区中已经存在该仓库，则忽略此步骤。）\n$ git clone https://codeup.aliyun.com/git-repo/demo.git  切换到本地仓库的工作区：\n$ cd demo  1.2 创建特性分支 在本地工作区中创建新的工作分支。这个步骤不是必须的，使用当前分支（如 master 分支）也可以。但是如果需要在一个工作区目录进行不同特性的开发，则创建分支是必要的，否则多个特性的代码可能混在同一个代码评审任务中，或相互覆盖。\n$ git checkout -b topic1 origin/master  上面命令的两个参数要重点说明一下：\n 参数 -b topic1 设定了新的工作分支的名称。 最后的 origin/master 参数，则是为了将新建分支和上游的 master 分支建立关联。这个参数很重要，如果忘了添加该参数，则在用 git peer-review 创建代码评审时，会提示补救方法。  1.3 工作区内开发和提交 在工作区中进行代码开发工作，使用标准的 git 命令进行提交。\n1.4 发起代码评审 当完成本地开发后，执行如下命令推送本地改动并创建代码评审：\n$ git pr  该命令的参数有很多，可以设置代码评审需要的各项参数，例如：\n  指定评审者和关注者。多个用户名之间可以用（半角）逗号分开。\n $ git pr --reviewers 星楚,澳明 --cc 知忧    设定代码评审处于草稿状态，可以发表评审意见，但是不能合入。\n $ git pr --draft    如果当前分支相比远程分支没有新提交，则不会创建代码评审，显示提示信息如下：\n$ git pr NOTE: no branches ready for upload  如果已经发起过一次代码评审，且之后没有代码改动，也不会执行。显示的提示信息如下：\n$ git pr NOTE: no change in project . (branch topic1) since last upload NOTE: no branches ready for upload  如果本地分支未跟踪某一个远程分支，则 git pr 命令不知道该向哪个远程分支发起代码评审。必须设置本地分支和远程分支的跟踪，才可以发起代码评审。命令报错信息如下：\n$ git pr FATAL: upload failed: cannot find tracking branch Please run command \u0026quot;git branch -u \u0026lt;upstream\u0026gt;\u0026quot; to track a remote branch. E.g.: git branch -u origin/master  参照提示信息中的命令，建立工作区本地分支和远程分支的跟踪关系。\n1.5 代码评审的编辑界面 输入 git pr 命令后，会打开一个编辑器，内容是此次代码评审的各项可定制的参数，内容如下：\n############################################################################## # Step 1: Input your options for code review # # Note: Input your options below the comments and keep the comments unchanged ############################################################################## # [Title] : one line message below as the title of code review # [Description] : multiple lines of text as the description of code review # [Issue] : multiple lines of issue IDs for cross references # [Reviewer] : multiple lines of user names as the reviewers for code review # [Cc] : multiple lines of user names as the watchers for code review # [Draft] : a boolean (yes/no, or true/false) to turn on/off draft mode # [Private] : a boolean (yes/no, or true/false) to turn on/off private mode ############################################################################## # Step 2: Select project and branches for upload # # Note: Uncomment the branches to upload, and not touch the project lines ############################################################################## # # project ./: branch topic1 ( 3 commit(s)) to remote branch master: # 03c01e211122b49fe05f48e08fd3e1dd1c52e57e # ec78989440697fbc13bfbd3ea082fe9b3fc5f2d7 # 4e599aa284ed64ba12ba1b5b06fbbd3199846434  其中以字符 \u0026ldquo;#\u0026rdquo; 开始的行是注释，不要改动注释行，因为 git-repo 要根据注释行的内容判断用户输入内容用于更改哪项代码评审的参数设置。 例如：\n 在 \u0026ldquo;# [Title]\u0026rdquo; 行的下面添加的内容，成为代码评审的标题。默认用提交说明的标题作为代码评审标题。 在 \u0026ldquo;# [Description]\u0026rdquo; 行的下面添加的内容，成为代码评审的详细描述。默认用提交说明的内容作为代码评审的详细描述。 在 \u0026ldquo;# [Issue]\u0026rdquo; 行的下面如果添加 Issue ID，则将代码评审和问题之间的建立关联。 在 \u0026ldquo;# [Reviewer]\u0026rdquo; 行的下面添加代码评审者姓名，一个一行，或者用逗号分隔。 在 \u0026ldquo;# [Cc]\u0026rdquo; 行的下面添加代码评审的关注者姓名，一个一行，或者用逗号分隔。 在 \u0026ldquo;# [Draft]\u0026rdquo; 行的下面如果输入 yes，则表明要创建一个草稿模式的代码评审。 在最下面的 \u0026ldquo;Step 2\u0026rdquo; 区域，显示当前项目将要上传到远程仓库的分支和提交列表。检查提交列表，如果不想创建此次代码评审，则将 \u0026ldquo;branch \u0026hellip;\u0026rdquo; 的行注释掉，或者删掉，则此次创建代码评审的任务终止。  保存内容，退出编辑器，则开始向服务端推送代码，并开始代码评审的创建。\n编辑的内容会以模板的方式保存，以便在下一次执行 git pr 时复用。\n1.6 完成代码评审的创建 git pr 命令执行完毕后，显示代码评审创建成功的消息，示例如下：\nremote: +------------------------------------------------------------+ remote: | Merge Request #7937 was created or updated. | remote: | View merge request at URL: | remote: | https://codeup.aliyun.com/git-repo/demo/merge_request/7937 | remote: +------------------------------------------------------------+ To ssh://codeup.aliyun.com/git-repo/demo.git * [new branch] topic1 -\u0026gt; refs/for/master/topic1  注意：提示信息中包含创建成功的代码评审的 URL 地址，通过浏览器访问该地址，显示创建好的代码评审。\n1.7 服务器端仓库的变化 通过命令行工具在服务器端创建代码评审，服务端不会创建新的分支，但是为了方便用户远程下载评审代码，仓库中生成了一个特殊的引用。\n例如上面创建的第 7937 号代码评审，会创建包含该评审 ID 号的特殊引用，如：refs/merge-requests/7937/head。下载该待评审的代码，可以使用如下命令：\n$ git fetch origin refs/merge-requests/7937/head From https://codeup.aliyun.com/git-repo/demo.git * branch refs/merge-requests/7937/head -\u0026gt; FETCH_HEAD  检出相关代码：\n$ git checkout FETCH_HEAD  git-repo 提供了一个便捷的 download 子命令完成上述操作。\n2. 重新发送，刷新代码评审 代码评审很少一蹴而就，针对评审者的意见，开发者（评审任务的创建者）往往需要重新上传代码刷新代码评审。对于阿里巴巴代码平台上创建的代码评审任务，重复执行 git pr 命令即可。\n  开发者首先在本地工作区修改代码。\n  执行如下命令，向远程仓库推送并刷新代码评审任务：\n $ git pr    3. 多人协同 代码评审者收到代码评审任务后，除了可以在代码评审 web 界面中添加评论之外，还可以使用 git-repo 更改评审中的代码。\n首先代码评审者在本地工作区（指向同一代码仓库）中，使用 git download 命令下载该代码评审任务指定的代码。例如下载 ID 为 7937 的代码评审：\n$ git download 7937  执行该命令后，本地工作区切换到该代码评审指向的提交。创建一个本地分支，例如：code-review 分支\n$ git checkout -b code-review  代码评审者在这个分支中进行修改，并完成本地的代码提交。\n然后代码评审者通过如下命令向远程服务器推送，并更新相应的代码评审。\n$ git pr --change 7937  说明：多人协同模式只支持 AGit-Flow 服务，而不支持 Gerrit 服务。\n","description":"","id":6,"section":"docs","tags":null,"title":"git peer-review","uri":"/zh_cn/docs/single-repo/git-peer-review/"},{"content":"功能 git download 是 git-repo 的一个别名命令，实现下载代码评审的源代码。默认使用 checkout 命令检出待评审的提交。\n命令格式 git download [options] \u0026lt;Merge-Request-ID\u0026gt; git download [options] \u0026lt;Change-ID\u0026gt;/\u0026lt;Patch-ID\u0026gt;  说明:\n 对于支持 AGit-Flow 协议的仓库，使用 \u0026lt;Merge-Request-ID\u0026gt; 格式下载评审代码。 对于属于 Gerrit 服务上的仓库，则使用 \u0026lt;Change-ID\u0026gt;/\u0026lt;Patch-ID\u0026gt; 格式，即斜线分隔的两个数字。  选项 主要的选项如下：\n -c, --cherry-pick：使用 cherry-pick 命令拣选代码评审的提交。 -f, --ff-only：使用 \u0026ndash;ff-only 参数合并代码评审的提交。 -r, --revert：只适用于 Gerrit，撤销评审的提交。  ","description":"","id":7,"section":"docs","tags":null,"title":"git download","uri":"/zh_cn/docs/single-repo/git-download/"},{"content":"功能 git abandon 是 git-repo 的一个别名命令，清理已经发起代码评审的本地分支。\n如果使用 --force 参数，强制删除分支，等价于 git branch -D \u0026lt;branchname\u0026gt; 命令。\n如果不使用 --force 参数（默认），则只清理已经发起代码评审的本地分支。\n命令格式 git abandon [options]  选项 主要的选项如下：\n --all: 删除所有分支。 -b, --branch：只删除指定分支。 --force：强制删除，即使本地分支尚未发起代码评审。  ","description":"","id":8,"section":"docs","tags":null,"title":"git abandon","uri":"/zh_cn/docs/single-repo/git-abandon/"},{"content":"在实践中，Git 大仓库存在着诸多问题：下载慢、不能对授权进行精细控制。解决大仓库的一个有效方案是化整为零：将大仓库拆分为多仓库。\n为了实现多仓库像一个仓库一样工作，Git提供一个原生的 submodule 方案，但是这个方案问题很多。例如：子模组固定在某个版本上，而不能实现随上游仓库分支更新而更新。多人修改子模组仓库，冲突从文件级别放大到仓库级别，让子模组的冲突不易解决。\nAndroid 项目创造了一个新的方案。即使用 XML 格式文件（manifest 清单文件）定义一个项目的多仓库关联，然后用 repo 客户端工具操作多仓库。\ngit-repo 使用 go 语言重新实现了 Android repo 工具多仓库管理功能，目标是实现和 Android repo 工具的 100% 兼容。\ngit repo 命令行格式如下：\ngit repo \u0026lt;子命令\u0026gt; \u0026lt;参数\u0026gt;  查看 git-repo 的帮助，使用命令：\ngit repo help git repo help \u0026lt;子命令\u0026gt;  使用 git-repo 管理多个代码仓库的典型使用场景，如下图所示：\n  图: git-repo 针对多仓库的操作\n  上面的演示场景中，主要步骤如下：\n  创建一个空目录，作为工作区。\n $ mkdir workspace $ cd workspace    通过克隆 manifest 清单仓库，完成工作区的初始化。\n $ git repo init -u \u0026lt;manifest-url\u0026gt;  例如:\n $ git repo init -u https://codeup.aliyun.com/git-repo/manifests.git    下载相关仓库代码\n $ git repo sync    创建开发分支\n $ git repo start --all \u0026lt;topic-branch\u0026gt;  例如：\n $ git repo start --all jx/topic1    在工作区中开发，每个仓库的改动单独完成本地提交。\n  执行下面命令，会扫描工作区所有仓库的改动，逐个向上游仓库发起代码评审。\n $ git repo upload    ","description":"","id":9,"section":"docs","tags":null,"title":"多仓库协同概览","uri":"/zh_cn/docs/multi-repos/overview/"},{"content":"Manifest 清单仓库和 Manifest 清单文件 定义多仓库关联的清单文件（manifest 文件）保存于一个仓库中，这个仓库称为 manifest 仓库。仓库中默认的 manifest 清单文件名为 default.xml，示例如下。（仓库中可以包含多个 XML 文件，但是除了默认的 default.xml 之外，其他 XML 文件需要通过命令行的相关参数显式的指定。）\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;remote name=\u0026quot;origin\u0026quot; fetch=\u0026quot;..\u0026quot; revision=\u0026quot;master\u0026quot; review=\u0026quot;https://codeup.aliyun.com\u0026quot; /\u0026gt; \u0026lt;remote name=\u0026quot;github\u0026quot; fetch=\u0026quot;https://github.com\u0026quot; revision=\u0026quot;master\u0026quot; review=\u0026quot;\u0026quot; /\u0026gt; \u0026lt;default remote=\u0026quot;origin\u0026quot; revision=\u0026quot;master\u0026quot; sync-j=\u0026quot;4\u0026quot; /\u0026gt; \u0026lt;project name=\u0026quot;alibaba/git-repo-go\u0026quot; path=\u0026quot;git-repo\u0026quot; groups=\u0026quot;app\u0026quot;\u0026gt; \u0026lt;linkfile src=\u0026quot;README.md\u0026quot; dest=\u0026quot;README.md\u0026quot;\u0026gt;\u0026lt;/linkfile\u0026gt; \u0026lt;/project\u0026gt; \u0026lt;project name=\u0026quot;alibaba/git-repo-go-doc\u0026quot; path=\u0026quot;website\u0026quot; groups=\u0026quot;app\u0026quot;/\u0026gt; \u0026lt;project name=\u0026quot;jiangxin/goconfig\u0026quot; path=\u0026quot;lib/goconfig\u0026quot; groups=\u0026quot;lib\u0026quot; remote=\u0026quot;github\u0026quot; /\u0026gt; \u0026lt;project name=\u0026quot;jiangxin/multi-log\u0026quot; path=\u0026quot;lib/multi-log\u0026quot; groups=\u0026quot;lib\u0026quot; remote=\u0026quot;github\u0026quot; /\u0026gt; \u0026lt;/manifest\u0026gt;  这是一个标准的 XML 文件，根元素为 manifest，关于该文件格式的解读如下。\nremote 元素 一个 Manifest 文件中可以包含多个 remote 元素。每一个 remote 元素定义了一个远程服务器。每个 project 元素都关联唯一一个 remote 元素。remote 元素包括的属性如下：\n name 定义 remote 的名称。仓库克隆时将以该名称建立和远程仓库的关联。 fetch 定义服务器 URL 地址。如果是 fetch 是相对地址，则以 manifest 仓库地址（git-repo init -u \u0026lt;URL\u0026gt; 设定的地址）为基准，计算得出。当一个项目被克隆时，将通过 fetch 定义的服务器 URL 地址和项目 name 字段组合得到仓库的克隆地址。 revision 定义项目的默认分支。 review 参数设置 git-repo 发动集中式评审的服务器地址。  default 元素 当项目（project）元素没有设置 remote、revison 等属性，则直接使用 default 元素中相关设置。即 default 元素为 project 元素相关属性的缺省值。\nproject 元素 每一个 project 元素定义一个仓库。其中关键属性如下：\n 属性 name 既作为项目的名称，又和 remote 的 fetch 字段一起组合出仓库的 URL 地址。 属性 path 是一个相对路径，是仓库在本地工作区的检出路径。 属性 groups 将项目分组，用作项目的筛选。例如在 git repo init -g \u0026lt;gorup 命令中进行设置。 属性 remote 设置项目对应的远程源仓库。  元素 project 还可以嵌套，嵌套内部的 project 路径以嵌套外部项目的路径为基准。\n元素 project 还可以包含 linkfile、copyfile 等元素，完成文件的链接和拷贝。\n更多示例参见 Android 项目的 manifest 仓库：\n地址：https://android.googlesource.com/platform/manifest  ","description":"","id":10,"section":"docs","tags":null,"title":"Manifest 格式","uri":"/zh_cn/docs/multi-repos/manifest-format/"},{"content":"功能 初始化当前工作区，或修改前一次 git repo init 执行时的参数设置。\n当 git repo init 命令执行完毕后，会在工作区中创建子目录 .repo。其中包含 manifest 清单仓库（.repo/manifests），以及清单文件（.repo/manifest.xml）文件。\n部分 git repo init 命令的参数会以 git 配置变量方式保存在 .repo/manifests.git 仓中，例如 -m \u0026lt;name\u0026gt;、-g \u0026lt;groups\u0026gt; 参数，就记录在 git 配置文件的 [manifest] 小节中。\n命令格式 git repo init -u \u0026lt;URL\u0026gt; [options...]  选项 主要的选项如下：\n -u \u0026lt;URL\u0026gt;：指定 manifests 清单仓库的 URL 地址。 -b \u0026lt;branch\u0026gt;：指定检出的 manifests 清单仓库分支，默认使用 master 分支。 -m \u0026lt;name\u0026gt;：指定使用的 manifest 清单文件名称，默认使用 default.xml 文件。 -g \u0026lt;groups\u0026gt;：指定项目分组。可以使用逗号分隔多个分组。分组在 manifest 清单文件中定义。  ","description":"","id":11,"section":"docs","tags":null,"title":"git repo init","uri":"/zh_cn/docs/multi-repos/git-repo-init/"},{"content":"功能 执行 sync 子命令，会在工作区克隆、检出、更新 manifest 清单中包含的仓库。\n首先更新 manfiest 仓库。\n和上一次更新的项目列表（.repo/project.list 文件）做对比，如果 manifest 中包含新增项目，则克隆和检出新项目，如果 manifest 清单中移除部分项目，则工作区中删除相关项目（如果这些项目中未做修改的话）。\n然后逐一更新工作区中的项目。\n  如果项目尚未同步到工作区，则 git repo sync 相当于 git clone。\n  如果项目已经同步到工作区，则 git repo sync 相当于：\n git remote update git rebase origin/branch    如果 git rebase 操作导致合并冲突，请使用常规 git 命令（例如 git rebase --continue）解决冲突。\n  命令格式 git repo sync [options...]  选项 主要的选项如下：\n  -c：只从服务端获取当前分支。\n  -d：工作区项目进入分离头指针状态，并切换到 manifest 清单文件指定的提交。该参数对于编译构建时严格按照 manifest 清单文件检出提交，丢弃工作区本地修改，非常有用。\n  -f：即使某个项目同步失败，也继续同步其他项目。\n  -j \u0026lt;num\u0026gt;：设定并发数。默认 4 个并发。\n  -n：只做网络端操作。即相当于只进行 git fetch 操作，不修改本地仓库的检出。\n  -l：只做本地端操作。即相当于只进行 git checkout 操作，而不进行任何网络操作。\n  ","description":"","id":12,"section":"docs","tags":null,"title":"git repo sync","uri":"/zh_cn/docs/multi-repos/git-repo-sync/"},{"content":"功能 以 manifest 清单仓库指定的版本为基准，为项目创建分支或切换分支。\n命令格式 只对指定的项目，创建或切换分支：\ngit repo start \u0026lt;branch-name\u0026gt; [project...]  为所有项目创建或切换分支，分支名 ：\ngit repo start --all \u0026lt;branch-name\u0026gt;  ","description":"","id":13,"section":"docs","tags":null,"title":"git repo start","uri":"/zh_cn/docs/multi-repos/git-repo-start/"},{"content":"功能 创建代码评审。\n对于指定的项目，git-repo 会将本地分支与上一次执行 git repo upload 时上传的提交做比较，（上一次上传提交记录在 refs/published/\u0026lt;branch-name\u0026gt; 的引用中），提示您选择一个或多个尚未上传可供审核的分支。\ngit repo upload 命令会启动一个编辑器，编辑器中的内容是此次代码评审的各项可定制的参数，以及待上传的项目和分支列表。\n示例如下：\n############################################################################## # Step 1: Input your options for code review # # Note: Input your options below the comments and keep the comments unchanged ############################################################################## # [Title] : one line message below as the title of code review # [Description] : multiple lines of text as the description of code review # [Issue] : multiple lines of issue IDs for cross references # [Reviewer] : multiple lines of user names as the reviewers for code review # [Cc] : multiple lines of user names as the watchers for code review # [Draft] : a boolean (yes/no, or true/false) to turn on/off draft mode # [Private] : a boolean (yes/no, or true/false) to turn on/off private mode ############################################################################## # Step 2: Select project and branches for upload # # Note: Uncomment the branches to upload, and not touch the project lines ############################################################################## # # project foo: # branch topic1 ( 3 commit(s)) to remote branch master: # 03c01e211122b49fe05f48e08fd3e1dd1c52e57e # ec78989440697fbc13bfbd3ea082fe9b3fc5f2d7 # 4e599aa284ed64ba12ba1b5b06fbbd3199846434 # # project bar: # branch topic1 ( 2 commit(s)) to remote branch master: # 47a3cae46019893db78a19906dda97825279f288 # ced1a1d6e16bc3f8051f87621eb69ba2a7e10672  Step 1 中以字符 \u0026ldquo;#\u0026rdquo; 开始的行是注释，不要改动注释行，因为 git-repo 要根据注释行的内容判断用户输入内容用于更改哪项代码评审的参数设置。 例如：\n 在 \u0026ldquo;# [Title]\u0026rdquo; 行的下面添加的内容，成为代码评审的标题。默认用提交说明的标题作为代码评审标题。 在 \u0026ldquo;# [Description]\u0026rdquo; 行的下面添加的内容，成为代码评审的详细描述。默认用提交说明的内容作为代码评审的详细描述。 在 \u0026ldquo;# [Issue]\u0026rdquo; 行的下面如果添加 Issue ID，则将代码评审和问题之间的建立关联。 在 \u0026ldquo;# [Reviewer]\u0026rdquo; 行的下面添加代码评审者姓名，一个一行，或者用逗号分隔。 在 \u0026ldquo;# [Cc]\u0026rdquo; 行的下面添加代码评审的关注者姓名，一个一行，或者用逗号分隔。 在 \u0026ldquo;# [Draft]\u0026rdquo; 行的下面如果输入 yes，则表明要创建一个草稿模式的代码评审。  在最下面的 \u0026ldquo;Step 2\u0026rdquo; 区域，显示当前项目将要上传到远程仓库的分支和提交列表。检查提交列表，如果不想创建此次代码评审，则将 \u0026ldquo;branch \u0026hellip;\u0026rdquo; 的行注释掉，或者删掉，如果需要为此项目和分支创建代码评审，则打开对应的 \u0026ldquo;branch \u0026hellip;\u0026rdquo; 行。\n例如将 project foo 的 branch topic1 所在行的注释去掉，而保留 project bar 的 branch topic1 行的注释。如下：\n############################################################################## # Step 2: Select project and branches for upload # # Note: Uncomment the branches to upload, and not touch the project lines ############################################################################## # # project foo: branch topic1 ( 3 commit(s)) to remote branch master: # 03c01e211122b49fe05f48e08fd3e1dd1c52e57e # ec78989440697fbc13bfbd3ea082fe9b3fc5f2d7 # 4e599aa284ed64ba12ba1b5b06fbbd3199846434 # # project bar: # branch topic1 ( 2 commit(s)) to remote branch master: # 47a3cae46019893db78a19906dda97825279f288 # ced1a1d6e16bc3f8051f87621eb69ba2a7e10672  保存并退出编辑器，则只向 project foo 发起代码评审，而不会向 project bar 发起代码评审。\n命令格式 git repo upload [options...] [project...]  选项 主要的选项如下：\n --cbr：为当前分支的修改创建代码评审。 --br \u0026lt;branch-name\u0026gt;：为指定的分支中的修改创建代码评审。 --re \u0026lt;user1,user2,...\u0026gt;：设置代码评审人。 --cc \u0026lt;user1,user2,...\u0026gt;：设置代码评审的关注人。 --title \u0026lt;title\u0026gt;：设置代码评审的标题。 --description \u0026lt;description\u0026gt;：设置代码评审的描述。 --single：单仓模式，可用于不使用 manifest 清单仓库的单仓库项目。  ","description":"","id":14,"section":"docs","tags":null,"title":"git repo upload","uri":"/zh_cn/docs/multi-repos/git-repo-upload/"},{"content":"功能 实现下载代码评审的源代码。默认使用 checkout 命令检出待评审的提交。\n命令格式 git repo download [options] \u0026lt;project\u0026gt; \u0026lt;Merge-Request-ID\u0026gt; ... git repo download [options] \u0026lt;project\u0026gt; \u0026lt;Change-ID\u0026gt;/\u0026lt;Patch-ID\u0026gt; ...  说明:\n \u0026lt;project\u0026gt; 和代码评审ID 成对出现。如果省略 \u0026lt;project\u0026gt; 默认为当前仓库。 对于阿里巴巴代码平台上的仓库，使用 \u0026lt;Merge-Request-ID\u0026gt; 下载评审代码。 对于 Gerrit 上的仓库，要使用 \u0026lt;Change-ID\u0026gt;/\u0026lt;Patch-ID\u0026gt;，即斜线分隔的两个数字。  选项 主要的选项如下：\n -c, --cherry-pick：使用 cherry-pick 命令拣选代码评审的提交。 -f, --ff-only：使用 \u0026ndash;ff-only 参数合并代码评审的提交。 -r, --revert：只适用于 Gerrit，撤销评审的提交。  ","description":"","id":15,"section":"docs","tags":null,"title":"git repo download","uri":"/zh_cn/docs/multi-repos/git-repo-download/"},{"content":"功能 该命令提供一个迭代器。可以为指定的每个项目运行指定的 shell 命令。\n在 git repo forall 的 shell 命令中，可使用下列额外的环境变量：\n REPO_PROJECT 是项目的唯一名称。 REPO_PATH 是相对于客户端根目录的路径。 REPO_REMOTE 是清单中远程系统的名称。  命令格式 git repo forall [project-list] -c command  选项 主要的选项如下：\n -c：要运行的命令和参数。此命令会通过 /bin/sh 进行评估，它之后的任何参数都将作为 shell 位置参数传递。 -e：如果一条命令执行失败，整个命令终止执行。 -p：在所指定命令的输出结果之前显示项目标头。 -g \u0026lt;groups\u0026gt;：通过组筛选项目，只对筛选后的项目执行指定命令。 -r \u0026lt;regexp\u0026gt;：通过正则表达式匹配项目名称，匹配的项目执行指定命令。 -i \u0026lt;regexp\u0026gt;：通过正则表达式排除项目名称，没有匹配的项目执行指定命令。  示例   在每个项目中执行 shell 命令，查看当前目录\n $ git repo forall -c 'echo \u0026quot;Project $REPO_PROJECT in `pwd`\u0026quot;' Project git-repo/demo in /Users/jiangxin/work/aliyun/git-repo-demo/demo Project git-repo/demo-vendor in /Users/jiangxin/work/aliyun/git-repo-demo/demo/vendor Project git-repo/demo-doc in /Users/jiangxin/work/aliyun/git-repo-demo/doc    显示最新一条 git 日志\n $ git repo forall -p -- git log -1 --oneline project demo/ 649941d topic1: initial project demo/vendor/ 443693b Initial vendor for project demo project doc/ 32f0be3 Initial doc for demo    ","description":"","id":16,"section":"docs","tags":null,"title":"git repo forall","uri":"/zh_cn/docs/multi-repos/git-repo-forall/"},{"content":"功能 显示项目工作区状态。每个项目的状态显示两个字符，分别表示索引、工作区的改动:\n在第一列中，大写字母表示索引中包含的更改。（相当于 git diff --cached。）\n   字母 含义 说明      | 没有变化 | 在 HEAD 与索引中相同    A | 已添加 | 不存在于 HEAD 中，但存在于索引中\nM | 已修改 | 存在于 HEAD 中，但索引中的文件已修改\nD | 已删除 | 存在于 HEAD 中，但不存在于索引中\nR | 已重命名 | 不存在于 HEAD 中，索引中文件的路径已更改\nC | 已复制 | 不存在于 HEAD 中，复制自索引中的另一个文件\nT | 模式已更改 | HEAD 与索引中的内容相同，但模式已更改\nU | 未合并 | HEAD 与索引之间存在冲突；需要加以解决\n在第二列中，小写字母表示工作区和索引之间的不同之处。（相当于 git diff。）\n   字母 含义 说明      | 新/未知 | 不存在于索引中，但存在于工作树中    m | 已修改 | 存在于索引中，也存在于工作树中（但已修改）\nd | 已删除 | 存在于索引中，但不存在于工作树中\n","description":"","id":17,"section":"docs","tags":null,"title":"git repo status","uri":"/zh_cn/docs/multi-repos/git-repo-status/"},{"content":"功能 删除已经发起代码评审的开发分支。\n如果使用 --force 参数，强制删除分支，等价于 git branch -D \u0026lt;branchname\u0026gt; 命令。\n如果不使用 --force 参数（默认），则只清理已经发起代码评审的本地分支。\n命令格式 git-repo abandon [options] [\u0026lt;project\u0026gt;...]  选项 主要的选项如下：\n --all: 删除所有分支。 -b, --branch：只删除指定分支。 --force：强制删除，即使本地分支尚未发起代码评审。  ","description":"","id":18,"section":"docs","tags":null,"title":"git repo abandon","uri":"/zh_cn/docs/multi-repos/git-repo-abandon/"},{"content":"功能 清理本地分支，删除已经被上游合并的本地分支。\n该命令等价于 git repo abandon --all [\u0026lt;project\u0026gt;...]。相比 git repo abandon 支持 --force 参数，本命名更加安全。\n命令格式 git-repo prune [\u0026lt;project\u0026gt;...]  ","description":"","id":19,"section":"docs","tags":null,"title":"git repo prune","uri":"/zh_cn/docs/multi-repos/git-repo-prune/"},{"content":"如果您在代码合并时发现 Git 合并结果不符合预期，您是否曾怀疑 Git 出现了 bug ？我希望您把这个选项放在最后。让我们一起来看看 Git-Merge 的那点事儿，一起来查找并解决代码合并的异常\u0026hellip;\n理解三路合并 Git 在分支合并时，采用三路合并的方法。不管合并的两个分支包含多少提交，Git 合并操作只关心代码的三个版本，即：合并双方的两个版本和一个基线版本。\n看下我们的示例程序，使用 Go 语言开发，执行结果如下：\n$ git clone https://github.com/jiangxin/git-merge-demo.git $ cd git-merge-demo $ git checkout demo-1/user-1 -- $ go build -o demo $ ./demo Topics: ♠ ♥ ♥ ♣  该示例程序输出一些符号，每行输出同一种符号，代表了某一个特性，符号个数代表该特性功能上的异同。\n我们可以看到 \u0026ldquo;demo-1/user-1\u0026rdquo; 分支上，\u0026ldquo;demo\u0026rdquo; 程序有三个特性。特性 \u0026ldquo;♠\u0026rdquo;（一颗）、特性 \u0026ldquo;♥\u0026rdquo;（两颗）、特性 \u0026ldquo;♣\u0026rdquo;（一颗）。\n同样我们在 \u0026ldquo;demo-1/user-2\u0026rdquo; 分支上会看到不同的特性输出：\n♠ ♠ ♠ ♥ ♥ ♥ ♦ ♦  这两个分支各自包含三个特性。如果要将这两个分支合并在一起，那么 \u0026ldquo;demo-1/user-1\u0026rdquo; 分支上独有的 \u0026ldquo;♣\u0026rdquo; 特性应该出现在最终的合并结果中么？\u0026ldquo;demo-1/user-2\u0026rdquo; 分支上独有的 \u0026ldquo;♦\u0026rdquo; 特性应该出现在最终的合并结果中么？对于双方共同拥有的 \u0026ldquo;♠\u0026rdquo; 特性在合并结果中是出现一次，还是重复出现三次呢？\n仅从上面这两个分支信息，我们很难推导出合理的合并结果。这时必须要考虑一个问题：这两个分支的特性是如何演变来的。我们要寻找这两个分支的共同的祖先提交，即寻找基线。\n借助 git merge-base 命令，我们可以看到基线提交编号是 228ec07：\n$ git merge-base --all demo-1/user-1 demo-1/user-2 228ec07e07ac83295b96be1ad55adfbd0c870f74  注意：上面命令中的 --all 参数会显示两个分支所有的基线提交，可能的结果有：\n 0 条基线。即两个分支没有重叠，没有公共的历史提交。 1 条基线。大多数合并场景两个分支存在一条基线。 多条基线。可能的场景有：1、两条分支都是集成分支，都接受来自各个特性分支的合入。2、特性分支之间存在依赖关系，复杂的特性分支和集成分支之间可能存在多条基线。  本例只有一条集成分支。从下面的 git-log 命令可以看出本例的两个分支提交历史还是很简单的，两个分支各自独有的提交标记为 \u0026ldquo;+\u0026rdquo; 和 \u0026ldquo;x\u0026rdquo;，共有的提交标记为星号。从这两个分支提交历史的重叠部分，我们很容易看出来重叠的顶端提交 228ec07 即是我们要找的基线提交。\n$ git log --graph --oneline demo-1/user-1 demo-1/user-2 + 34b76a2 (demo-1/user-2) Topic 4: ♦ ♦ + dfdce61 Remove topic 3 + 68bc440 Topic 2: ♥ ♥ ♥ | x 55e002f (demo-1/user-1) Topic 1: ♠ |/ * 228ec07 (demo-1/base) Topic 3: ♣ * d1f0d8c Topic 2: ♥ ♥ * 8f19971 Topic 1: ♠ ♠ ♠ * bfdeca2 Demo for git 3-way merge  切换到基线提交 228ec07 上执行看看：\n$ git checkout 228ec07 -- $ make Topics: ♠ ♠ ♠ ♥ ♥ ♣  下图综合了该程序三个版本，那么合并版本是不是呼之欲出了呢？\n基线版本 User-1 版本 User-2 版本 合并版本 ======== ============= ============= =========== ♠ ♠ ♠ ♠ ♠ ♠ ♠ ? ♥ ♥ ♥ ♥ ♥ ♥ ♥ ? ♣ ♣ ? ♦ ♦ ?  对于特性 ♠ ，相比基线版本，User-1将其修改为一颗，User-2 没有修改；对于特性♥，相比基线，User-1没有修改，User-2将其修改为三颗；对于特性♣，User-1没有修改，User-2将其删除；而对于特性♦，是由 User-2 新引入的特性。\n让我们执行命令来看一下真实的合并结果吧：\n$ git checkout demo-1/user-1 $ git merge demo-1/user-2 $ make Topics: ♠ ♥ ♥ ♥ ♦ ♦  Revert 操作引发的“异常”合并结果 下面我们来看一个“异常”的合并。\n在分支 \u0026ldquo;demo-2/topic-1\u0026rdquo; 运行，显示如下：\n$ git checkout demo-2/topic-1 $ make ◉ ◉ ◉ ▲ ▲ △ △ △  其中特性 ◉ 是主干 \u0026ldquo;demo-2/master\u0026rdquo; 引入的特性。Topic-1 引入两个子特性： ▲ 和 △ 。\n在分支 \u0026ldquo;demo-2/topic-2\u0026rdquo; 运行，显示如下：\n$ git checkout demo-2/topic-2 $ make ◉ ◉ ◉ ♡ ♡ ♡  在主干分支 \u0026ldquo;demo-2/master\u0026rdquo; 运行，显示如下：\n$ git checkout demo-2/master $ make ◉ ◉ ◉ ◉ ♡ ♡ ♡  我们可以看出主干分支的特性 ◉ 演进了，而且已经包含了 \u0026ldquo;demo-2/topic-2\u0026rdquo; 分支的特性。\n现在将 \u0026ldquo;demo-2/topic-1\u0026rdquo; 分支合并到主干分支 \u0026ldquo;demo-2/master\u0026rdquo;，看看合并解决是否符合预期：\n$ git checkout demo-2/master $ git merge demo-2/topic-1 $ make ◉ ◉ ◉ ◉ △ △ △ ♡ ♡ ♡  看出问题了么？\u0026ldquo;demo-2/topic-1\u0026rdquo; 分支的特性没有全部合入，只合入了特性 △ ，而丢失特性 ▲ !\n让我们来分析一下：\n  先撤回刚刚的合并提交。\n $ git reset --hard HEAD^    计算合并基线：\n $ git merge-base --all demo-2/topic-1 demo-2/master 5db8ab7c5c1d2ede82096ae890446c290a664060    切换到这个基线版本：\n $ git checkout 5db8ab7c5c1d2ede82096ae890446c290a664060 -- $ make ◉ ◉ ◉ ▲ ▲    基线版本有特性 ▲ ，分支 \u0026ldquo;demo-2/topic-1\u0026rdquo; 也有特性 ▲ ，但是主干分支 \u0026ldquo;demo-2/master\u0026rdquo; 上并没有特性 ▲。\n按照三路合并的原理分析，我们看出合并结果丢失特性 ▲ 是预料中的：\n 基线 5db8ab7 demo-2/master demo-2/topic-1 合并版本 ============ ============= ============== ======== ◉ ◉ ◉ ◉ ◉ ◉ ◉ ◉ ◉ ◉ ◉ ◉ ◉ ◉ ▲ ▲ ▲ ▲ △ △ △ △ △ △ ♡ ♡ ♡ ♡ ♡ ♡    下面命令用于查询基线 5db8ab7 之后主干分支的变更，看看哪个提交删除了特性 ▲ ：\n $ git log --stat --oneline 5db8ab7..demo-2/master .... .... e50fc0b Topic 1 is not complete, and is not ready for merge topic/topic-1.1.go | 20 -------------------- 1 file changed, 20 deletions(-) .... ....    从上面的日志输出，我们看到主干分支 \u0026ldquo;demo-2/master\u0026rdquo; 上的一个可疑提交 e50fc0b。这个提交删除了文件 \u0026ldquo;topic-1.1.go\u0026rdquo;。提交说明表明“因为当时 topic1 功能尚未完整，故撤回不完整的合并提交”。\n如何才能将 \u0026ldquo;demo-2/topic-1\u0026rdquo; 特性完整地合入呢？采用如下操作：\n  对提交 e50fc0b 再次执行一次撤回操作。\n $ git checkout demo-2/master -- $ git revert e50fc0b    然后再合并分支 \u0026ldquo;demo-2/topic-1\u0026rdquo;。\n $ git merge demo-2/topic-1    执行程序，查看合并效果。\n $ make ◉ ◉ ◉ ◉ ▲ ▲ △ △ △ ♡ ♡ ♡    操作完成，我们看到 \u0026ldquo;demo-2/topic-1\u0026rdquo; 分支完整的特性都合入了。\n“脏合并”引发的“异常” 下面我们来看另外一个“异常”的合并。\n在当前版本的开发分支 \u0026ldquo;demo-3/master\u0026rdquo; 运行，显示如下：\n$ git checkout demo-3/master $ make ◉ ◉ ◉ ◉ ◉ ♠ ♠ ♠ ♠ ♦ ♦ ♦  其中特性 ◉ 是主干 \u0026ldquo;demo-3/master\u0026rdquo; 引入的特性。其余两个特性 ♠ 和 ♦ 是从相应的特性分支合入的。\n接下来，在下一个版本的开发分支 \u0026ldquo;demo-3/next\u0026rdquo; 中运行，显示如下：\n$ git checkout demo-3/next $ make ❍ ❍ ❍ ❍ ♠ ♠ ♠ ♠ ♥ ♥ ♦ ♦ ♦  其中特性 ❍ 是新版本主干 \u0026ldquo;demo-3/next\u0026rdquo; 引入的特性。其余三个特性 ♠、♥ 和 ♦ 是从相应的特性分支合入的。\n现在要将当前版本 \u0026ldquo;demo-3/master\u0026rdquo; 合入到下一个新版本的开发分支 \u0026ldquo;demo-3/next\u0026rdquo; 中，运行如下：\n$ git checkout demo-3/next $ git merge demo-3/master $ make ◉ ◉ ◉ ◉ ◉ ❍ ❍ ❍ ❍ ♠ ♠ ♠ ♠ ♦ ♦ ♦  我们看到合并后，\u0026ldquo;demo-3/master\u0026rdquo; 分支的特性 ◉ 被引入了，但是 \u0026ldquo;demo-3/next\u0026rdquo; 分支原有的特性 ♥ 被删除了。如果特性 ♥ 是需要的，那么合并后为何会丢失特性 ♥ 呢？\n我们按照三路合并的原理来分析一下。\n首先查看下分支 \u0026ldquo;demo-3/master\u0026rdquo; 以及分支 \u0026ldquo;demo-3/next\u0026rdquo; 合并前提交（即 \u0026ldquo;demo-3/next~1\u0026rdquo;）的基线：\n$ git merge-base --all demo-3/master demo-3/next~1 e54a597938d7aaa20c8b3ce79d0b6c5bca8404e7 6b57153213757421f83523d1b03f7743aa654160 b2c844810a095a4e05763ffaff326101e61d444f  惊奇的发现，基线居然有三条！这实际上是三个特性分支分别向 \u0026ldquo;demo-3/master\u0026rdquo; 和 \u0026ldquo;demo-3/next\u0026rdquo; 分支合入后的结果。\n我们使用命令 git log --graph --oneline demo-3/master demo-3/next~1 查看合并双方的提交。如果只显示两个分支重合的部分，如下图所示：\n * 6b57153 (demo-3/topic-3) Topic 3: ♦ ♦ ♦ * f1dca57 Topic 3: ♦ / / | | * b2c8448 (demo-3/topic-2) Topic 2: ♥ ♥ | * 60f846d Topic 2: ♥ |/ | | * e54a597 (demo-3/topic-1) Topic 1: ♠ ♠ ♠ ♠ | * 3ccbd75 Topic 1: ♠ ♠ | * 18ea90f Topic 1: ♠ |/ | | * bfdeca2 (tag: v0) Demo for git 3-way merge  会看到有三个端点对应三条基线。\n那么对于多基线场景，如何来分析呢？\nGit 会将多条基线合并为一个提交，再将这个提交作为唯一的基线，参与到三路合并中。\n$ git checkout -b demo-3/base e54a597 $ git merge 6b57153 b2c8448 $ make ♠ ♠ ♠ ♠ ♥ ♥ ♦ ♦ ♦  列出下列表格分析三路合并结果：\n基线 base master 分支 next 分支 合并结果 ========= ============ ========== ========== ◉ ◉ ◉ ◉ ◉ ◉ ◉ ◉ ◉ ◉ ❍ ❍ ❍ ❍ ❍ ❍ ❍ ❍ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♠ ♥ ♥ ♥ ♥ ♦ ♦ ♦ ♦ ♦ ♦ ♦ ♦ ♦ ♦ ♦ ♦  从上面表格可以看出来，特性 ♥ 在基线中存在，在 \u0026ldquo;demo-3/next\u0026rdquo; 分支中也存在，但是被 \u0026ldquo;demo-3/master\u0026rdquo; 中删除了。所以导致合并结果中缺失了特性 ♥ 。\n那么 \u0026ldquo;demo-3/master\u0026rdquo; 分支是如何在基线 \u0026ldquo;demo-3/base\u0026rdquo; 之后删除了特性 ♥ 的呢？\n在一段提交历史中找出一个有问题的版本有很多办法，例如使用 git bisect 二分查找命令。不过这里使用 git log 命令就足够了。\n使用如下命令查看这段历史中非合并提交：\n$ git log --oneline --stat --no-merges demo-3/base..demo-3/master 05f2ec3 (origin/demo-3/master, demo-3/master) Topic master: ◉ ◉ ◉ ◉ ◉ topic/master.go | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 5daade4 Topic master: ◉ ◉ ◉ ◉ topic/master.go | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 6325a3f Topic master: ◉ ◉ ◉ topic/master.go | 19 +++++++++++++++++++ 1 file changed, 19 insertions(+)  看到非合并提交都是在修改特性 ◉ 的，和特性 ♥ 无关。\n那么问题一定出在合并提交中。不过使用下面命令看不出来合并提交包含了哪些修改，你知道为什么吗？\n$ git log --oneline --stat --merges demo-3/base..demo-3/master 3a69a8a Merge branch 'demo-3/topic-3' into demo-3/master 37544d1 Merge branch 'demo-3/topic-2' into demo-3/master d872d8f Merge branch 'demo-3/topic-1' into demo-3/master  合并提交是将两个或多个提交合并在一起，因此合并提交有两个以上的父提交。合并的结果要么选择合并的某一方的版本，要么和任何一方版本都不一样，综合了各方版本的修改。\n使用 git log -p 或者 git log --stat 显示提交差异，默认是不会显示合并提交差异的。Git 提供以下三个参数改变 git log 或 git diff 的行为，显示合并提交包含的差异。分别是：\n  参数 -m：分别显示合并提交和每一个父提交的差异。如果合并有两个父提交，则分别显示两个差异比较的结果。\n  参数 -c：将合并提交和各个父提交的差异合并在一起显示。如果和某个父提交相同，则不显示。\n  参数 --cc：类似 -c，进一步精简补丁的显示，忽略和某一方相同的补丁的显示。\n  对于本例，使用 -m 参数，执行结果如下：\n$ git log --oneline -m --stat --merges demo-3/base..demo-3/master 3a69a8a (from 37544d1) Merge branch 'demo-3/topic-3' into demo-3/master topic/3.go | 19 +++++++++++++++++++ 1 file changed, 19 insertions(+) 3a69a8a (from 6b57153) Merge branch 'demo-3/topic-3' into demo-3/master topic/1.go | 19 +++++++++++++++++++ topic/master.go | 19 +++++++++++++++++++ 2 files changed, 38 insertions(+) 37544d1 (from b2c8448) Merge branch 'demo-3/topic-2' into demo-3/master topic/1.go | 19 +++++++++++++++++++ topic/2.go | 19 ------------------- topic/master.go | 19 +++++++++++++++++++ 3 files changed, 38 insertions(+), 19 deletions(-) d872d8f (from 6325a3f) Merge branch 'demo-3/topic-1' into demo-3/master topic/1.go | 19 +++++++++++++++++++ 1 file changed, 19 insertions(+) d872d8f (from e54a597) Merge branch 'demo-3/topic-1' into demo-3/master topic/master.go | 19 +++++++++++++++++++ 1 file changed, 19 insertions(+)  从输出中我们看到合并提交 37544d1 删除了 topic/2.go 文件。经查这个提交就是导致特性 ♥ 丢失的罪魁祸首。\n$ git log -1 37544d1 commit 37544d18c2da92a265acd6a7a8145bed4ba51bd8 Merge: 5daade4 b2c8448 Author: Jiang Xin \u0026lt;zhiyou.jx@alibaba-inc.com\u0026gt; Date: Sun Mar 15 19:53:56 2020 +0800 Merge branch 'demo-3/topic-2' into demo-3/master * demo-3/topic-2: Topic 2: ♥ ♥ Topic 2: ♥ Signed-off-by: Jiang Xin \u0026lt;zhiyou.jx@alibaba-inc.com\u0026gt;  如何解决合并 demo-3/master 分支丢失特性 ♥ 的问题呢？\n我们需要重新执行一次和提交 37544d1 类似的合并：\n$ git checkout 5daade4 -- $ git merge b2c8448 $ make ◉ ◉ ◉ ◉ ♠ ♠ ♠ ♠ ♥ ♥  我们看合并的结果中出现了特性 ♥。\n然后再和错误的提交 37544d1 做一次合并，并使用当前提交中的内容。\n$ git merge -s ours 37544d1 $ make ◉ ◉ ◉ ◉ ♠ ♠ ♠ ♠ ♥ ♥  记下这个合并提交。\n$ git tag -m \u0026quot;fixed merge\u0026quot; fixed-merge  切换到 \u0026ldquo;demo-3/next\u0026rdquo; 分支，合并这个刚刚创建好的正确的提交。\n$ git checkout demo-3/next -- $ git merge fixed-merge $ make ◉ ◉ ◉ ◉ ◉ ❍ ❍ ❍ ❍ ♠ ♠ ♠ ♠ ♥ ♥ ♦ ♦ ♦  完美的合并结果。\n建议   创建 pull request 代码评审时，不要在其中包含合并提交。\n因为合并提交的差异很难查看和分析，不要因此增加代码评审者的负担。开发者可以使用 git rebase 命令去掉不必要的合并提交。\n  如果做到了第一点，就不会出现多基线的情况。要避免多基线。\n多基线一方面增加了三路合并分析的复杂度，另外一方面导致 pull request 展示的代码差异是错的！因为绝大多数代码平台从执行效率考虑，都只会选择多条基线中的一条来和 pull request 的源分支进行比较，显示代码差异。读者可以翻到前面的示例，看看如果选择多条基线中的一条（而不是使用多条基线的合并结果）与要合并的代码进行代码比较，会是什么样的结果？\n  使用 git merge 命令完成分支合并，而不要使用目录比较工具去人为判断合并结果。\n因为人工选择合并结果可能造成“脏合并”，“脏合并”像是埋在提交记录中的一枚炸弹，会在未来随时引爆。\n  If not now, when? if not me, who? 如果你是一个懂代码，爱Git，有技术梦想的工程师，并想要和我们一起打造世界NO.1的代码服务和云产品，请联系我们吧！C/C++/Golang/Java 我们都要 💖\n简历投递邮箱：\n zhiyou.jx@alibaba-inc.com worldhello.net@gmail.com  ","description":"","id":20,"section":"posts","tags":null,"title":"Git-Merge 的那点事儿","uri":"/zh_cn/2020/03/something-about-git-merge/"},{"content":"Git Merge 2020 Git 的全球盛会 Git Merge 2020 于 2020年3月4日在美国洛杉矶召开，因为新冠病毒引发的疫情，作为演讲嘉宾的我，虽然早早买好了北京和洛杉矶之间的往返机票，最终还是没能成行。\n这次会议我的议题是 “AGit-Flow 和 git-repo”，这也是我在 2019年云栖大会演讲“Go Git：面向未来的代码平台”做出的承诺，将阿里巴巴代码平台的技术开放给全世界。本文就是原计划在 Git Merge 2020 上的演讲稿，文中介绍的相关核心软件均已开源。\n为什么 Git 能成功？ Git 成为了源代码管理的标准和基础设施。为什么 Git 能够成功？\nLinus 作为 Git 和 Linux 的创建者，在 Git 十周年的一次采访中，道出了其中的奥秘：\n The big thing about distributed source control is that it makes one of the main issues with SCM’s go away – the politics around “who can make changes.”\n 其中的关键词是“politics”（政治）。传统的集中式版本控制系统只能针对核心用户开放写授权，而把大量的潜在的代码贡献者拒之门外，参与项目贡献的门槛高，而这对项目的发展不利。Git 作为分布式版本控制工具，拥有更加灵活的工作流，不仅仅是项目的核心成员，只读用户也可以使用更加优雅的方式参与代码开发。\n最为常用的两种 Git 工作流 当前两种主流的 Git 协同方式分别是 GitHub 和 Gerrit 提出和普及的。这两种协同模式能够做到：\n  仓库的授权模型简单。无需为项目设置复杂的授权，只读用户亦可参与代码贡献。\n  通过代码评审提升代码质量。参与者不是将代码直接推送的分支上，而是创建代码评审。\n  仓库的分支模型简单。仓库中没有多余的分支，即不需要创建特性分支。\n    图: GitHub、Gerrit 协同模式比较\n  这两种协同模型的差异非常明显：\n  代码评审的模式不同。\nGitHub 的代码评审称为 “pull request”，每个特性生成一次代码评审。\nGerrit 的代码评审称为 “Change”，每个提交生成一个单独的代码评审。\n  工作流的类型不同。\nGitHub 的工作流属于分布式，代码贡献者的代码先提交到自己完全自主可控的派生仓中。\nGerrit 的工作流是集中式，所有用户工作在统一管控的集中式仓库中。\n  实现细节不一样。\nGitHub 模式是仓库派生和创建 pull request。GitHub 底层采用的是原生的 Git（即 CGit）。\nGerrit 要求用户在本地克隆仓库中安装一个 \u0026ldquo;commit-msg\u0026rdquo; 钩子，以便在生成的提交中插入唯一的“Change-Id”，向服务器推送要使用特殊的 git push 命令。Gerrit 采用的是 JGit（Java 的 Git 实现）。\n  各自的优势：\nGitHub 工作流使用标准 Git 操作，使用简单。派生仓自主可控，不受上游项目影响。项目复用、全球开发者大协同，形成了最大的开源社区。\nGerrit 项目管控更严格；采用 manifest 仓库管理多仓库协同，相比 git-submodule 更加实用。\n  各自的劣势：\nGitHub 使用派生仓库的工作模式，对于一次性参与项目贡献显得太重了，而且对于多仓库项目难于管理。很难想象在 GitHub 上如何使用派生工作流来管理类似 Android 的多仓库类型的项目。\nGerrit 需要集中管控，由管理员负责创建项目，而普通用户不能创建项目，这就使得一个 Gerrit 实例通常只管理一个项目或一个组织内的项目，难以在项目之间形成代码复用，也很难汇集跨项目的开发者组成开发者社区。\n  AGit-Flow 的使用 什么是 AGit-Flow ？ 我们能否将 GitHub 和 Gerrit 两种工作流结合到一起（不是 GerritHub 的那种集成模式），兼具他们的优点？\n在 Gerrit 的启发下，我们在 CGit 的基础上创建了一个集中式 Git 工作流，其中包含对 Git 核心做的少量修改和几个服务端API。我们称之为 “AGit-Flow”，最早在阿里巴巴的内部代码平台中实现。使用 AGit-Flow 工作流，无需创建派生仓库，也无需在仓库中创建特性分支，只读用户就可以通过 git push 命令创建代码评审。\n  图: AGit-Flow 功能概览\n  在阿里巴巴，我们喜欢 pull request、CGit，喜欢在命令行直接创建代码评审的集中式工作流，喜欢开放的开发者社区。我们不喜欢 \u0026ldquo;commit-msg\u0026rdquo; 钩子方式关联提交的代码评审，我们不喜欢一个一个分散的代码平台。\n我们还开发了配套的命令行工具 “git-repo”，既能在单仓库下工作，又支持类似 Android 的多仓库项目协同。\nAGit-Flow 工作流 单仓库下 AGit-Flow 工作流如下图所示：\n  图: 单仓库 AGit-Flow 协作流程图\n  图中的两个角色，一个是开发者，另外一个是评审者。\n开发者通过如下操作，创建和更新 pull request：\n  开发者克隆仓库。\n  本地仓库内开发，创建提交。\n  工作区中执行 git pr 命令，推送本地提交到服务器。\n  服务器自动创建新的代码评审（例如：pull request #123）。\n  开发者根据评审意见，在本地工作区继续开发，新增或修改提交。\n  工作区中再次执行 git pr 命令，推送本地提交到服务器。\n  服务器发现目标分支上已经存在来自同一用户、同一本地分支的 pull request，因此用户此次推送没有创建新的 pull request，而是更新已经存在的 pull request。\n  代码评审者，不但可以给出评审意见，也可以直接发起对评审代码的修改，更新 pull request：\n 代码评审者执行 git download 123 下载编号为 123 的 pull request 到本地仓库。\n  代码评审者本地修改代码后，执行 git pr --change 123 命令，将本地修改推送到服务端。\n  服务端接收到代码评审者的特殊 git push 命令，更新之前由开发者创建的 pull request。\n  项目管理者通过点击 pull request 评审界面的合并按钮，将 pull request 合入 master 分支。master 分支被更新，同时关闭 pull request。\n  下面是单仓库下 AGit-Flow 工作流的演示，代码平台使用阿里巴巴·云效（https://codeup.aliyun.com/）。\n  图: AGit-Flow 单仓库操作演示\n  AGit-Flow 服务端实现 客户端使用特殊的 git push 命令向服务端发起代码推送请求，触发 AGit-Flow 工作流。\n这个 git push 命令的特殊之处主要在于特殊的引用表达式：\n$ git push origin HEAD:refs/for/\u0026lt;target-branch\u0026gt;/\u0026lt;session\u0026gt;  即：\n  引用表达式的目标分支包含特殊的前缀 \u0026ldquo;refs/for/\u0026quot;，用于向远程仓库特定分支 \u0026ldquo;\u0026lt;target-branch\u0026gt;\u0026rdquo; 发起代码评审。其中的 \u0026ldquo;\u0026lt;session\u0026gt;\u0026rdquo; 通常使用客户端工作区本地分支名。多次 git push 请求，如果是相同用户、相同的目标分支、相同的 \u0026ldquo;\u0026lt;session\u0026gt;\u0026quot;，则对应用同一个 pull request。\n  AGit-Flow 中还有 \u0026ldquo;refs/drafts/\u0026quot;、\u0026ldquo;refs/for-review/\u0026rdquo; 等特殊前缀。\n前缀 \u0026ldquo;refs/drafts/\u0026rdquo; 的格式和 \u0026ldquo;refs/for/\u0026rdquo; 类似，也是针对目标分支创建或者更新 pull request，区别在于创建的 pull request 处于草稿状态，只能发表评审意见，不能合入。\n前缀 \u0026ldquo;refs/for-review/\u0026rdquo; 后面跟指定的 pull request ID，用于更新指定的 pull request。\n  客户端触发 AGit-Flow 工作流，服务端各个模块及其处理流程示意如下：\n  图: AGit-Flow 服务端实现\n  前端授权模块 前端授权模块在处理用户的推送请求时，要检查用户是否拥有写授权。只读用户是不允许执行 git push 命令向服务器推送的。而一个“polictis”正确的集中式工作流，要允许只读用户向仓库贡献代码，如何才能实现呢？\n如果既要保持对常规 git push 推送命令采用严格的授权模型，又要对 AGit-Flow 的特殊推送降低授权要求，允许来自只读用户的推送操作，是否可以做到呢？\n我们使用的方法是传递特殊的环境变量（SSH协议）或者特殊的HTTP头（HTTP协议），如下图所示：\n  图: AGit-Flow 前端授权模块\n  说明如下：\n  对于 HTTP 协议，客户端发起的 git push 推送命令要通过 -c http.extraHeader=AGIT-FLOW: \u0026lt;agent-version\u0026gt; 参数设置 git 配置变量，使得 git 在向服务端发送请求时，设置指定的 HTTP HEADER。\n  对于 SSH 协议，使用 \u0026ldquo;GIT_SSH_COMMAND\u0026rdquo; 环境变量设置使用指定的 SSH 客户端命令。这个 SSH 客户端命令中包含特殊的参数 -o SendEnv=AGIT_FLOW，这样使用 SSH 协议时，就能将环境变量 \u0026ldquo;AGIT_FLOW\u0026rdquo; 传递给服务器端。\n  当服务器前端接收到特殊的环境变量（SSH协议）或者特殊的HTTP头（HTTP协议），就会识别出 AGit-Flow 模式的推送指令，采用特殊的授权检查。\n  注意：为防止用户通过设置特殊环境变量方式越权推送，还需要在 \u0026ldquo;pre-receive\u0026rdquo; 钩子脚本中对授权做进一步检查。\n  Git 核心改造和 post-receive 钩子 接下来客户端请求传递给 \u0026ldquo;git-receive-pack\u0026rdquo;。原生的 \u0026ldquo;git-receive-pack\u0026rdquo; 工作流如下图所示：\n  图: 原生的 git-receive-pack 工作流\n    客户端请求分为两个部分 \u0026ldquo;commands\u0026rdquo; 和 \u0026ldquo;packfile\u0026rdquo; 依次发送到服务端的 \u0026ldquo;git-receive-pack\u0026rdquo; 进程。\n  \u0026ldquo;packfile\u0026rdquo; 会进入到隔离区（quarantine），而 \u0026ldquo;commands\u0026rdquo; 被解析后，先传递给 \u0026ldquo;pre-receive\u0026rdquo; 钩子脚本。\n  如果 \u0026ldquo;pre-receive\u0026rdquo; 钩子脚本失败，则删除隔离区，并返回错误信息，终止推送命令的执行。\n  如果 \u0026ldquo;pre-receive\u0026rdquo; 钩子脚本执行成功，则隔离区中的 \u0026ldquo;packfile\u0026rdquo; 移动到仓库的对象库中。\n  而命令 \u0026ldquo;commands\u0026rdquo; 传递给内置的 execute_commands 函数，执行 commands（实现分支的创建、更新、删除等操作）。\n  最后执行 \u0026ldquo;post-receive\u0026rdquo; 等钩子脚本，完成事件通知等。\n  AGit-Flow 对 \u0026ldquo;git-receive-pack\u0026rdquo; 的源码做了改动，相关改动已经贡献到 Git 社区，参见：\n https://public-inbox.org/git/20200304113312.34229-1-zhiyou.jx@alibaba-inc.com/。  新的流程如下图所示：\n  图: AGit-Flow 对 Git 核心的改动\n  为支持 AGit-Flow，我们对 \u0026ldquo;git-receive-pack\u0026rdquo; 做了如下修改：\n  在 \u0026ldquo;git-receive-pack\u0026rdquo; 的入口增加了一个命令过滤器。\n  过滤器将 \u0026ldquo;commands\u0026rdquo; 分作两组，一组执行原生的 \u0026ldquo;git-receive-pack\u0026rdquo; 流程，另外一组 \u0026ldquo;commands\u0026rdquo; 不执行内部的 execute_commands 函数，而是调用一个新的外部钩子 \u0026ldquo;proc-receive\u0026rdquo; 执行 \u0026ldquo;commands\u0026rdquo;。\n  \u0026ldquo;proc-receive\u0026rdquo; 钩子将执行结果报告给 \u0026ldquo;receive-pack\u0026rdquo;，并由 \u0026ldquo;receive-pack\u0026rdquo; 通知客户端（调用 report() 函数）。\n  具体参见下面的介绍。\n配置变量：receive.procReceiveRefs   客户端的推送请求通过标准输入传递给服务端（git-receive-pack），每个命令一行，格式为：\n\u0026lt;旧的oid\u0026gt; \u0026lt;新的oid\u0026gt; \u0026lt;引用名称\u0026gt;  常规 git push 推送命令的引用名称是以 \u0026ldquo;refs/heads/\u0026rdquo; 或 \u0026ldquo;refs/tags/\u0026rdquo; 作为前缀。而 AGit-Flow 模式的推送命令的引用名称中使用不同的前缀。\n我们为 Git 引入了一个新的配置变量 \u0026ldquo;receive.procReceiveRefs\u0026rdquo;，用于区分 AGit-Flow 模式的引用前缀名称。这个配置变量是一个多值变量。例如在阿里巴巴的代码平台，我们会进行如下的设置：\ngit config --system --add receive.procReceiveRefs refs/for git config --system --add receive.procReceiveRefs refs/drafts git config --system --add receive.procReceiveRefs refs/for-review  上面的指令为该配置变量设置了三个值，来自客户端的 command 指令中的引用名称如果和这三个值任意一个相匹配，则 command 会打上特殊的标记，在后面的执行中会选择另外的处理逻辑。\n新钩子 proc-receive 被打上了特殊标记的 的命令，不再通过内置的 execute_commands 函数执行，而是调用外部的钩子来执行命令、更新引用。\n\u0026ldquo;receive-pack\u0026rdquo; 和 钩子 \u0026ldquo;proc-receive\u0026rdquo; 之间通过 pkt-line 格式的协议进行交互。如下图所示：\n    \u0026ldquo;receive-pack\u0026rdquo; 和 \u0026ldquo;proc-receive\u0026rdquo; 进行版本协商。\n\u0026ldquo;receive-pack\u0026rdquo; 首先通过 pkt-line 编码发送协议版本号和能力（capabilities）给钩子，钩子回复自己所支持的协议版本号和能力。当前协议版本号为1，从服务端向客户端传递的能力有 \u0026ldquo;push-options\u0026rdquo;, \u0026ldquo;atomic\u0026rdquo; 等。\n  \u0026ldquo;receive-pack\u0026rdquo; 向 \u0026ldquo;proc-receive\u0026rdquo; 发送命令和 push-options。\n命令每个一行，格式为 \u0026lt;old-oid\u0026gt; \u0026lt;new-oid\u0026gt; \u0026lt;reference\u0026gt;，使用 pkt-line 编码，以 flush-pkt 结束。\n只有在版本协商阶段双方都支持 \u0026ldquo;push-options\u0026rdquo;，\u0026ldquo;receive-pack\u0026rdquo; 才向 \u0026ldquo;proc-receive\u0026rdquo; 发送 push-options。\n  \u0026ldquo;proc-receive\u0026rdquo; 钩子调用外部 API 执行用户推送的命令。在阿里巴巴，这个被 \u0026ldquo;proc-receive\u0026rdquo; 钩子调用的 API 用于创建或者更新代码评审（pull request）。\n  \u0026ldquo;proc-receive\u0026rdquo; 钩子执行完毕，向 \u0026ldquo;receive-pack\u0026rdquo; 报告执行结果。支持如下格式的报告：\n  ok \u0026lt;ref\u0026gt;\n引用 \u0026lt;ref\u0026gt; 更新成功。\n  ng \u0026lt;ref\u0026gt; \u0026lt;reason\u0026gt;\n引用 \u0026lt;ref\u0026gt; 更新失败，原因由 \u0026lt;reason\u0026gt; 提供。\n  alt \u0026lt;ref\u0026gt; [\u0026lt;alt-ref\u0026gt;] [old-oid=\u0026lt;oid\u0026gt;] [new-oid=\u0026lt;oid\u0026gt;] [forced-update]\n预期更新 \u0026lt;ref\u0026gt;，但实际更新的引用为 \u0026lt;alt-ref\u0026gt;，可选参数可以用于设置 old-oid、new-oid、强制更新模式。\n  ft \u0026lt;ref\u0026gt;\n交由 \u0026ldquo;receive-pack\u0026rdquo; 执行该命令。ft 为 fallthrough 的简写。\n    向客户端报告 \u0026ldquo;proc-receive\u0026rdquo; 向标准错误的输出信息，直接显示给客户端。例如 \u0026ldquo;proc-receive\u0026rdquo; 可以用此方法将创建好的 pull request 地址通知给用户。\n命令 git push 执行完毕，客户端会显示命令执行结果。我们对 Git 报告机制做了扩展，可以显示实际更新的引用。\n  例如执行下面命令：\n$ git push origin HEAD:refs/for/master/topic  新版本 Git 显示的执行结果中可以包含实际更新的引用，而非 refs/for/master/topic。示例如下：\nTo \u0026lt;URL/of/upstream.git\u0026gt; + 263ea37...e5a9ada HEAD -\u0026gt; refs/pull/123/head (forced update)  Public API: ssh-info Gerrit HTTP 服务提供了 ssh_info API 接口，返回 Gerrit 的 SSH 服务器的 IP 和端口。这样像 repo 这样的命令行客户端就可以使用 SSH 协议进行推送操作，免除口令认证的麻烦等。\nAGit-Flow 对 ssh_info API 进行了拓展，返回值可以是 JSON 格式，内容包含协议类型和版本等。拓展后的 ssh_info 可以视为 \u0026ldquo;Smart Submit Handler information\u0026rdquo; 的缩写。AGit-Flow 不但在 HTTP 服务中提供该 API，还在 SSH 服务上也提供 ssh_info 命令，用于判断服务端是否支持集中式评审、协议类型和版本等。\n下图是 Gerrit、Agit-Flow 服务的 ssh_info API 的返回值。不同的协议，git push 命令格式和代码评审获取的引用名称各不相同。未来如果有其它的 AGit-Flow 兼容协议，也会有不同的 ssh_info 输出，有不同的 git push 命令和不同的 pull request 引用名称。\n  图: ssh_info API\n  git-repo git-repo 是阿里巴巴开源的一款命令行工具，对原生 Git 命令做了封装，简化了使用 AGit-Flow 等集中式工作流时稍嫌繁琐的 Git 命令。git-repo 可以支持 AGit-Flow 兼容的代码平台以及 Gerrit。\ngit-repo 使用 Golang 开发，在使用上兼容 Android 的 repo，并且运行时除 Git 外不依赖其他软件。除了具备 Android repo 的多仓库管理能力外，还可以对单独的代码仓库进行操作。\n  网址：https://git-repo.info\n  源代码：https://github.com/alibaba/git-repo-go\n  安装 访问 git-repo 的下载页面：https://github.com/alibaba/git-repo-go/releases。\n根据您平台的类型，下载合适的软件包。然后将下载并解压缩后的 git-repo 文件移动到可执行目录中（如 Linux 下的 /usr/local/bin 目录），即完成安装。\n运行 初次运行任意 git-repo 子命令，会完成一些初始化工作。例如执行下面的命令查看版本号：\ngit repo version  下面的这些针对单仓库的别名命令，就是通过 git-repo 初始化安装的 Git 配置文件扩展实现的：\n  图: git-repo 别名命令\n  单仓库下工作 如果工作区当前分支未关联远程分支，先执行操作和远程仓库的远程分支建立关联。例如：如下命令建立和远程仓库 origin 的 master 分支建立关联。\ngit branch -u origin/master  然后执行如下命令，从命令行发起代码评审：\ngit pr  参见下面的演示：\n  图: git pr 命令演示\n  多仓库下工作 git-repo 支持 Android 模式的多仓库工作流。\n  创建工作区。\n $ mkdir workspace $ cd workspace    下载 Manifest 清单仓库，初始化工作区。\n $ git repo init -u \u0026lt;manifest repository\u0026gt;    按照 Manifest 清单仓库中的文件，下载各个子仓库的代码，并检出到工作区。\n $ git repo sync    创建开发分支。\n $ git repo start --all \u0026lt;branch/name\u0026gt;    在工作区中开发，在各自独立的仓库中修改和完成提交。\n  执行下面命令，扫描工作区所有仓库的改动，逐个向上游仓库发起代码评审。\n $ git repo upload    参见下面的多仓库工作流演示：\n  图: git-repo 多仓库操作演示\n  扩展 git-repo git-repo 不仅支持 Gerrit 和 AGit-Flow 服务，还支持其他与 AGit-Flow 兼容的服务。添加一个新的服务可以通过两种方式实现：\n  方法一：在 git-repo 的 helper 目录中添加新的 protocol helper，实现 ProtoHelper 接口。这种方法适于那些提供对外服务的 Git 代码平台。\n  方法二：提供外部 helper 程序，通过 --upload、--download 等参数返回 git push 命令、代码评审引用名称等信息。这种方法适用于那些私有的代码平台。\n    图: git-repo 的协议扩展\n  总结 开源地址 AGit-Flow 是受 Gerrit 启发重新设计和开发的 Git 集中式协同方案。底层基于 CGit、不需要仓库派生、使用 pull request 进行代码评审。\ngit-repo 是使用 Go 语言开发的，与 Android repo 兼容的 AGit-Flow 客户端。\n相关代码已经开源：\n  https://github.com/alibaba/git-repo-go （欢迎加 ⭐️）\n  https://github.com/alibaba/git-repo-go-doc （网站 https://git-repo.info 代码）\n  https://public-inbox.org/git/20200304113312.34229-1-zhiyou.jx@alibaba-inc.com/ （Git核心的代码修改）\n  未来已来，抢先体验 AGit-Flow AGit-Flow 是一套开放的协议，已经在如下代码平台提供服务。\n 阿里巴巴·云效2.0 : https://codeup.aliyun.com/  为即将到来的 Git 2.27，实现你自己的“AGit-Flow”   为你的 AGit-Flow 兼容协议起个名字。\n  修改前端授权，以便允许只读用户执行特殊的推送操作。\n  服务器上安装带有 AGit-Flow 补丁的 Git 核心，并设置相关的 Git 配置变量以开启相关功能。\n  开发 \u0026ldquo;proc-receive\u0026rdquo; 钩子和内部创建代码评审（pull request）的 API。\n  在 HTTP 和 SSH 服务中开发对外服务的 ssh_info API，返回 JSON 格式数据，实现服务发现。\n  在 git-repo 中添加内置 helper 或者外部 helper 程序扩展，以支持你的“AGit-Flow”。\n  编辑记录：\n 2020/4/27: 钩子重命名，从 \u0026ldquo;execute-commands\u0026rdquo; 改名为 \u0026ldquo;proc-receive\u0026rdquo;。 2020/4/27: \u0026ldquo;receive-pack\u0026rdquo; 和 \u0026ldquo;proc-receive\u0026rdquo; 钩子之间使用 pkt-line 协议。  ","description":"","id":21,"section":"posts","tags":null,"title":"AGit-Flow 阿里巴巴集中式 Git 工作流","uri":"/zh_cn/2020/03/agit-flow-and-git-repo/"}]